#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#include <stack>
#include <cstring>
#include <string>

using namespace std;

int main() 
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    int n, k;
    cin >> n >> k;

    vector<int> coins;

    for(int i = 0; i < n; i++)
    {
        int coin_value;
        cin >> coin_value;
        coins.push_back(coin_value);
    }

    vector<int> dp(10001, 0);
    dp[0] = 1;

    for(int coin_value : coins)
    {
        for(int i = coin_value; i <= k; i++)
        {
            if(i - coin_value >= 0)
            {
                dp[i] += dp[i - coin_value];
            }
        }
    }

    cout << dp[k];

    return 0;
}

/*

흠...

시간 제한 0.5초, 메모리 제한 4MB << 심상치않음

---
n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. 각각의 동전은 몇 개라도 사용할 수 있다.

사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.
---

걍 DP라는 걸 모르고 문제 켰다고 해도 DP임

첫째 줄에 n, k가 주어짐 -> n : 동전의 종류의 수, k : 가치의 합

둘 째 줄부터 n개의 줄에 동전의 가치가 각각 주어진다


흠....

1 <= n <= 100, 1 <= k <= 10000

dp를 하는데..

예시

3 10
1
2
5

에서... 출력이 10

이걸 어떻게 DP 식으로 생각할지 처리해보자.

일단 1을 10개 쓰는 경우가 1개 존재할 것임

2를 5개 쓰고?

5를 2개 쓰고...

이렇게 1개씩을 쓰게 되는 경우가 3개가 있다.

모든 동전에 대해서 각각 1개씩 나오는가? 하면 그렇지 않을 수 있다

만약 여기서 동전의 가치 중 3이 있다고 하면

3은 단일로 10을 만들어낼 수 없다...

단일로 전부 만든다 = 약수이다 라는 의미인데

그렇지 않은 경우에는? 

흠...

일단 

dp[i] = i원을 만드는 경우의 수...

dp[0] = 1 << 아무 동전도 쓰지 않음

dp[1] = ? << 1원을 만드는데... 동전 중에 1원이 있는가? 있으면 1, 없으면 0

dp[2] = ? << 2원을 만드는데 만약 2원이 동전 중에 있으면 1을 더하게 될 것임. 어디에?

            dp[2] = dp[1] + dp[0] << 이게 맞나?
            그러니까 dp[2] = dp[2 - 2] + dp[2 - 1] + (동전 2가 있으면 1 추가) << 이게 맞나?

아니 그러면 dp[1] = dp[0] + @ 가 아니긴 함

만약 1원 동전이 없는데 그래서 @가 0이 되어서 dp[1] = dp[0] + 0 = 1 이 되면 안됨

dp[0]은 점화식에서 고려할 사항이 맞는가?

생각해보면 아닌 걸지도 모른다

수를 좀 높여서 생각했을 때에,

dp[5] =

if(1이 존재) -> dp[4]를 더함
if(2가 존재) -> dp[3]을 더함
if(5가 존재) -> dp[0]을 더함

이면 dp[0]이 고려되긴 한다

어 이거 맞는??것같은??디

dp[i] = dp[i - coin[j]] 식으로

j < i 여야 하나? 아니면 j <= i 여야 하나?

dp[5]의 예시를 보면 j <= i 여야 할듯

그러면 dp[0] = 1로 두고

dp[1] = dp[1 - 1] = dp[0] = 1 인데, 만약 1원이 존재하지 않으면 이건 0이 되어야 함

이런 부분의 예외 처리는 어떻게 해야 할까

이게 dp[0] = 1 이라는 것 자체가 아무 동전도 사용하지 않는 경우가 1가지 존재한다는

그것 외에도, dp[i] = 0 으로 초기화 되어있고, 동전의 가치가 i인 것이 존재하지 않으면

점화식에서 dp[i] = dp[i - coin[j]] 를 수행하지 않게 하면 될 듯

정확히는 동전의 가치가 i인 것이 존재하지 않는 경우 뿐 아니라, i를 만들 수 없는 경우라고 해야 할듯?

예를 들어서 2원짜리 동전이 없다고 해도 1원이 존재하면 어떻게든 dp[2]는 0보다 클 수 있다.

그러면

dp[0] = 1
dp[1] = coin[1] > 0 ? dp[1 - coin[1]] : 0 << 이런 식이라면 coin 배열은 동전의 가치가 존재하는지 여부를 저장하는 배열이어야 할 듯
dp[2] = coin[2] > 0 ? dp[2 - coin[2]] :... 잠깐만 그러면 dp[2-2] 를 어떻게 하지?

dp[0] = 1
dp[1] = coin[1] > 0 ? dp[1 - 1] : 0
dp[2] = coin[2] > 0 ? dp[2 - 2] + dp[2 - 1] : dp[2 - 1]
dp[3] = coin[3] > 0 ? dp[3 - 3] + dp[3 - 2] + dp[3 - 1] : dp[3 - 2] + dp[3 - 1]
dp[4] = coin[4] > 0 ? dp[4 - 4] + dp[4 - 3] + dp[4 - 2] + dp[4 - 1] : dp[4 - 3] + dp[4 - 2] + dp[4 - 1]
dp[5] = coin[5] > 0 ? dp[5 - 5] + dp[5 - 4] + dp[5 - 3] + dp[5 - 2] + dp[5 - 1] : dp[5 - 4] + dp[5 - 3] + dp[5 - 2] + dp[5 - 1]

이런 식이 맞는가?

dp[i] = coin[i] > 0 ? dp[i - i] + dp[i - (i - 1)] + ... + dp[i - 1] : dp[i - (i - 1)] + ... + dp[i - 1]

이런 식이면 되는? 것일지도 모른다. 한 번 해 보자.

씁...

반례를 찾았는데

2 3
2
1

에서, 출력이 3이 나오는데 정답은 2임
dp[3] = coin[3] > 0 ? dp[3 - 3] + dp[3 - 2] + dp[3 - 1] : dp[3 - 2] + dp[3 - 1]
      = dp[1] + dp[2]
      = (dp[0]) + (dp[1] + dp[0])
      = 1 + (1 + 1)
      = 3

이걸 풀어서 보면

3의 값을 갖는 동전이 존재하지 않으므로 3원 1개를 써서 3원을 만드는 경우는 없다

2원이 존재하면, 1원을 만들 수 있는 경우의 수에서 2원을 추가하는 경우의 수가 존재

1원이 존재하면, 2원을 만들 수 있는 경우의 수에서 1원을 추가하는 경우의 수가 존재

여기서 왜 2가 정답이어야 하는가?

1 + 2
1 + 1 + 1

인 것인데

1원을 만들 수 있는 경우의 수
- 1원 1개

2원을 만들 수 있는 경우의 수
- 2원 1개
- 1원 2개

에서, 3가지가 나와버린다.

그러니까, 2원을 만들 수 있는 경우의 수에 이미 1원을 만들 수 있는 경우의 수가 포함되어 있는 것임
모든 케이스가 그렇지는 않겠지만 이 케이스는 그러함

그러면, 만약

dp[i] = dp[i - coin]을 하는 경우에 그 dp[i - coin]이 0인지도 체크해야 하나?

그러니까 반복문을 순회하는 과정에서

coin[j] > 0 인데 dp[i - coin[j]]가 > 0 이 아니다? 그러면 continue하고

coin[j] > 0 인데 dp[i - coin[j]]가 > 0 이다? 그러면 dp[i] += dp[i - coin[j]] 를 수행

수행 하고 나면 반복문이 이중이니까 안쪽이 아닌 바깥에서 continue 하는 게 맞는?

2 7
1
5

의 경우를 보자.

1원을 만들 수 있는 경우의 수는 1
2원을 만들 수 있는 경우의 수는 1
3원을 만들 수 있는 경우의 수는 1
4원을 만들 수 있는 경우의 수는 1
5원을 만들 수 있는 경우의 수는 2
6원을 만들 수 있는 경우의 수는 2
7원을 만들 수 있는 경우의 수는 2

가 되는데

이러면 dp[i - coin[j]] > 0은 상관이 있나?

어쟀든 존재하는 coin[j]에 대해서 dp[i - j] 만 수행하면 되는 것이 아닌가?

dp[i] = coin[i] > 0 ? dp[i - i] + dp[i - (i - 1)] + ... + dp[i - 1] : dp[i - (i - 1)] + ... + dp[i - 1]

에서

dp[i] = coin[i] > 0 ? dp[i - i] + dp[i - (i보다 작고 제일 큰 coin)] : dp[i - (i보다 작고 제일 큰 coin)]

의 식이면 되는 것인지?

아니면, coin[i] > 0인 모든 i를 배열로 만들어서 그 배열 내에서 dp[i] = dp[i - coin[j]] (j는 coin 배열 내의 인덱스)

로 수행하게 하는 게 맞는 것인지?

오래 생각한 결과는

지금의 로직이 저러한 edge case들을 커버할 수가 없기 때문에

vector<int> coin(100, 0); 의 형태가 아니라
vector<int> coins;에서 그냥 push_back으로 동전을 넣고
거기서 sort를 한 번 해 주고...
위에서 잠깐 생각했던 사례

dp[5] =

if(1이 존재) -> dp[4]를 더함
if(2가 존재) -> dp[3]을 더함
if(5가 존재) -> dp[0]을 더함

와 같이 해야 하는 게 아닌지?

이걸 다시 보면

for(int coin : coins)
{
    for()
    {
 
    }

}

의 형태에서... coin : coins로 순회하는데?
이 내부는 어떻게 할 것인가?

dp[5] =

if(1이 존재) -> dp[4]를 더함
if(2가 존재) -> dp[3]을 더함
if(5가 존재) -> dp[0]을 더함

에서... 1이 존재 2가 존재 5가 존재 는 coin : coins에 대한 것이고

1이 존재 : dp[4]를 더함 -> dp[4]가 뭔데요? -> 하면 top-down 방식임
그 과정에서 어쩌면 dp[4]를 한 번 참조하는 게 아닐 수 있을 것 같은데
bottom-up 방식이면 새로운 dp값이 구해질 때 한 번만 참조되는 것 아닌지?
0.5초에 대한 경각심이 좀 있다...

머리가 복잡하네

그러니까 coin : coins의 순회는 내림차순으로 sort된 상황이면 top-down 이고
오름차순이면 bottom-up 인가 싶은데

sort의 기본이 오름차순이니까 bottom-up을 한다고 하면

대...충 감이 오는 것 같다.

예를 들면 1 동전에 대한 케이스에서

모든 dp[i]에 대해서 i의 값이 증가할 때에 계속 이전과 같은 수가 될 것임

왜냐면 전부 1로만 채워지니까

그런데 2 동전에 대한 케이스에서

1 동전의 순회와 같은 인덱스의 dp[i]를 만날 때에 이전 1의 순회에서 참조했던 dp[i]들을 참조하기도 하고 거기에 += 하기도 함

이렇게 동전에 대해서 반복하게 되는 것이 맞는 듯. dp 배열은 0으로 초기화를 했으니 문제가 없다.

아마 이게 맞는??????????듯??????????

*/