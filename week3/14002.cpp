#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#include <stack>
#include <cstring>
#include <string>

using namespace std;

int main() 
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    int N;
    cin >> N;

    if(N == 0)
    {
        cout << 0 << '\n';
        return 0;
    }

    vector<int> arr(N);
    for(int i = 0; i < N; i++)
    {
        cin >> arr[i];
    }

    vector<int> dp;
    vector<int> LIS;
    vector<int> index(N);

    LIS.push_back(arr[0]);
    index[0] = 0;

    for(int i = 1; i < N; i++)
    {
        if(arr[i] > LIS.back())
        {
            LIS.push_back(arr[i]);
            index[i] = LIS.size() - 1;
        }
        else
        {
            auto it = lower_bound(LIS.begin(), LIS.end(), arr[i]);
            *it = arr[i];
            index[i] = distance(LIS.begin(), it);
        }
    }

    int len = LIS.size();
    cout << len << '\n';

    // 여기까지는 맞다 이거임... 이제 LIS를 어떻게든 해야 함

    int target = len - 1;

    for(int i = N - 1; i >= 0; i--)
    {
        if(index[i] == target)
        {
            dp.push_back(arr[i]);
            target--;
        }
    }

    for(int i = dp.size() - 1; i >= 0; i--)
    {
        cout << dp[i] << ' ';
    }

    cout << '\n';

    return 0;
}
/*

---
수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 

A = {10, 20, 30, 50} 이고, 길이는 4이다.

첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)

첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.

둘째 줄에는 가장 긴 증가하는 부분 수열을 출력한다. 그러한 수열이 여러가지인 경우 아무거나 출력한다.
---

흠...

예제 입력 1

6
10 20 10 30 20 50

예제 출력 1

4
10 20 30 50

뭐임 이게...

어떤 수열의 크기가 주어지고

그 수열의 원소가 주어지면...

'가장 긴' '증가하는' '부분 수열' 은 뭐임

부분 수열이 뭐임

literally 수열의 원소를 일부 뽑아서 만드는 것임?

집합과 부분 집합의 관계임? 그런 듯함

그러면 '증가하는' 은 뭐임?

수열의 인덱스가 증가함에 따라서 수열의 원소도 증가하는 것임?

그런 듯함...

'가장 긴'은 뭐임?

원래의 수열 A에서 가장 길게 뽑을 수 있는 부분 수열이라는 것임?

그러니까 저 예제 출력 1에서

10 20 30 만 뽑을 수도 있는 건데

가장~~ 길게 뽑으니까 50까지도 포함하면 제일 길게 뽑았어요~~ 가 되는 것임?

그리고 10 20 10 30 20 50 에서

10과 20은 중복해서 나타나는데

10 20 30 50 에서는 중복이 없음

이말인 즉슨 부분 수열에는 중복된 원소가 존재하지 않는다고 인식해야 하는 것인가?

그런 듯함...

흠 그리고 시간제한이 1초이고 메모리 제한 256MB 라는 것과

1 <= N <= 1000, 1 <= A_i <= 1000 이라는 건

O(N^2) 까지도 허용될 수 있는 범위일지 모른다.

그리고 이게 DP 문제임을 알고 있는 상황임

또한 이 문제의 예제 케이스에서는

10 20 10 30 20 50 처럼 방심할 수도 있는 식으로 줬는데

50 20 30 10 20 10 식으로 줄 수도 있다는 것을 염두에 두어야 하지 않나?

dp 테이블을 어떻게 둬야 할까?

그리고 어떻게 점화식을 세워서... 어떤 로직으로

이 dp 테이블을 채워 나가고

무엇을 출력해야 하는 것인가

첫째 줄에는 길이를 출력하고

둘째 줄에는 수열을 출력해야 한다.

흠...

dp로 길이를 구할 수 있을 것인데

수열은 또 별개로 계산되어야 하는?

dp[i] : 가장 긴 증가하는 부분 수열... 의 길이

LIS[i] : 가장 긴 증가하는 부분 수열

의 식으로 cout 하자

일단

arr을 입력 받고...

LIS[0] = 0
dp[0] = 0

으로 둔 상태에서 시작하자... 그리고 제일 마지막 인덱스를 size로 보면 될 것이다.

즉 vector의 size에서 -1을 해 주어야 한다.

0이 있는 상태에서

첫 원소를 보게 되면, 0보다 크니까 10을 LIS에 삽입

그리고 나서 20을 보게 되면, 10보다 크니까 20을 LIS에 삽입

그리고 나서 10을 보게 되면, 20보다 작다.

이 때 분기를 해야 하나?

LIS의 마지막 원소보다 작으면,

LIS의 원소들을 순회하면서 10보다 크거나 같은 원소가 나오는 그 위치에

10을 삽입한다.

이를 반복한다.

이런 식으로 진행하면

30을 보게 되면, 20보다 크니까 LIS에 30을 삽입

20을 보게 되면, 30보다 크니까 순회. 인덱스 2에서 20이 있고

20보다 크거나 같다. 이 자리에 20을 삽입.

50을 보게 되면, 20보다 크니까 LIS에 50을 삽입

이게... DP가 맞나?

내가 DP를 잘못 생각하고 있었나?

이건 백트래킹? 일지도 모르겠는데

백트래킹이 맞나? 딴생각하지 말자

구현해봅시다

뭔 이딴...

테스트 케이스(1개밖에 없음 ㅋㅋ)를 맞추긴 헀는데

testcase.ac에서의

3
56 63 49

에서

2
49 63 
를 출력했는데, 정답은

2
56 63 

라고 함

왜?

그니까 이 원래 수열에서의 순서를 멋대로 바꿀 수가 없다는 것임

그래서 원래 수열 56 63 49에서

56 63이 가장 긴 증가하는 부분수열이고

49를 앞으로 가져온다거나 하는 짓을 할 수가 없는 것임


오랜 생각을... 거치고 옴

이건 DP라고 하기보다는

부분수열 문제라고 해야 맞지 않나...

그 과정에서 사용되는 알고리즘들의 그것들이 있는 것이지...

어쨌든 기존의 그것에서... 위치를 저장하는 배열을 하나 더 만들어서

그 위치를 기반으로 LIS를 재구성한다는 것도 생각해보자



*/