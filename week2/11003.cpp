#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#include <stack>
#include <cstring>
#include <string>

using namespace std;

int main() 
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    int N, L;
    cin >> N >> L;

    vector<int> A(N);

    deque<int> dq;

    for(int i = 0; i < N; i++)
    {
        cin >> A[i];
    }

    for(int i = 0; i < N; i++)
    {
        while(!dq.empty() && dq.front() < i - L + 1)
        {
            dq.pop_front();
        }

        while(!dq.empty() && A[dq.back()] > A[i])
        {
            dq.pop_back();
        }

        dq.push_back(i);

        cout << A[dq.front()] << " ";
    }

    return 0;
}

/*

N개의 수 A[N]이 주어짐.
L이 주어짐.
>> 첫째 줄에 N과 L이 주어짐.

D[i] = A[i-L+1] ~ A[i] 중의 최솟값이다. 이 때 D에 저장된 수를 출력하라. 인데...
둘째 줄에는 N개의 수 A[N]이 주어짐...

문제 조건 중에

i <= 0인 A[i]는 무시하고 D를 구해야 한다 << 라고 적혀 있는데...

이건 뭔 소리냐?

예시를 보자.

N = 12 / L = 3
A = {1, 5, 2, 3, 6, 2, 3, 7, 3, 5, 2, 6}

출력

D = {1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 2, 2}

????

뭐여

그러니까, 어떤 sliding window에서 최솟값을 찾아가면서 D라는 배열을 만들어 나가는 것 같은데...

저 예시에서 D[1]을 구해보자

i = 1
- D[1] = min_element(A[1-3+1] ~ A[1]) = min_element(A[0] ~ A[1]) = min_element(1, 5) = 1 
- 이런 식으로 A <= 0에 대해서 무시한다는 게, 그냥 index가 음수이면 0으로 처리하세요, 같은 의미인가?
- 그렇다고 생각하고 해 봅시다...

i = 2
- D[2] = min_element(A[2-3+1] ~ A[2]) = min_element(A[0] ~ A[2]) = min_element(1, 5, 2) = 1

이런 식으로 계속 구한다. 라고 한다면,

i는 어디까지인 것이지? i를 당연하게 N개라고 생각해도 되는 걸까?

내가 술을 얼마나 처먹은 거지... 당연히 ~A[i]까지 보는 거니까 i는 N까지 아니냐? 정신 안차릴래?

아무튼 이걸 i = 0; i < N; i++로 돌리면 되는 거 아니냐?

이게 왜 플레지? 분명 이런 생각 하다가 쳐맞는다

일단 구현해보고 생각하자.

구현하려다가 무서운 사실을 깨닫고 말았음

A[N]을 그냥 deque로 선언하든 vector로 선언하든 큰 상관이 없긴 한데

여기서 min_element를 사용하게 되는 것은 O(N)의 비용이 소모됨
근데 이걸 매 i마다 한다? 이것도 O(N)이니까
결론적으로 O(N^2)가 된다.

최악의 경우를 생각해보면... L, N <= 5000000이니까

5000000 * 5000000 = 25000000000000 이고 이건

250000초가 필요하다는 뜻인데...

1시간이 3600초니까 이건 개 말도안되는 이야기라는 소리다...

그러면 이건 min_element를 갈기면서 하는 작업이 아니라는 거고

거기서 deque를 잘 써야 한다는 뜻이다...

내가 이걸 sliding window 개념에 대해서 인지하고 있는 부분이

아마도 deque의 핵심이 되는 게 아닌가 싶은데... 생각 좀 해봅시다.

일단 위의 방법을 한 번 해보기나 하자.

해 보니까 바로 시간초과 나옴...

이게, 결국 index를 지정하게 되어도 O(N^2) 문제는 발생할 수밖에 없는 것 같다.

그러면 deque를 어떻게 해야 잘 쓸 수 있을까?

바킹독 영상을 좀 정주행 하는 게 좋겠다는 딴소리를 해봅니다

분명 학교 수업으로 듣긴 헀는데... 잘 가르쳐 주셨는데 이런 부분에서 구멍이 있네

어쩄든 이전 stack에서 그랬듯이

그냥 멍청하게 생각하면 O(N^2)이 될 작업들을

자료구조의 특성......을 이용해서 O(N)으로 만드는 일들이 있다

이 deque도 그런 게 분명 있을 것임

deque는 앞뒤로 입출력을 다 할 수 있으니까...

이런 씨@발 어떻게 써야 하지?

생각이 안 나네

이... deque를, window 용으로 사용한다고 생각하자.

현재 주어진 index 범위의 window를, deque를 통해 관리한다... 고 생각?

N = 12 / L = 3
A = {1, 5, 2, 3, 6, 2, 3, 7, 3, 5, 2, 6}

출력

D = {1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 2, 2}

i = 0
- D[0] = min_element(A[0-3+1] ~ A[0]) = min_element(A[0] ~ A[0]) = min_element(1) = 1
일단 deque에 push.
뭘? 음...

i = 1
- D[1] = min_element(A[1-3+1] ~ A[1]) = min_element(A[0] ~ A[1]) = min_element(1, 5) = 1 


i = 2
- D[2] = min_element(A[2-3+1] ~ A[2]) = min_element(A[0] ~ A[2]) = min_element(1, 5, 2) = 1

일단 첫 원소는 push가 될 것임...

다른 원소들도 조건에 따라 push/pop 될 텐데

그게 어떤 조건이 될까?

deque를 단순히 sliding window로만 본다면

현재 window에 벗어나면 pop 하게 되고...

현재 window에 포함되게 되면 + 최소값이면 push 하게 되겠지

그럴 때에

pop << 그럴 수 있음

push << 어떻게?

음

그러니까...

i에 따라서 순회를 하는데... 목적이 O(n)으로 하려는 거니까 (스택에서도 그랬듯)

결론적으로는 현재 인덱스에 대한 것을 deque에 push하게 된다

일단 첫 i = 0에서는 조건이고 뭐고 push하게 될 것이고... 이 때 deque는 1임

i = 1에서 i = 0에서 넣은 것이 윈도우에 포함되니까 pop 하지 않을 것이고?

i = 1은 5였으니까 5를 push하게 됨 이 때 deque는 1, 5 임...

i = 2는 2였으니까 2를 push하게 됨 이 때 deque는 1, 5, 2임

i = 3은 3이었으니까 3을 push하게 되면 deque는 1, 5, 2, 3이 됨

이것이 의미가 있나?

ㅇ나

출력이 1 1 1 2 2 2 2 2 3 3 2 2 인데

이 때 deque의 첫 원소가 1인 window인 것임 이어서 해 보면

i = 4는 6이었으니까 6을 push하게 되면 이 때 deque는 1, 5, 2, 3, 6이 되는데

deque를 이런식으로 계속 쌓기만 하는 게 아니라

어떻게 pop 하고 어떻게 push 하는가?

i = 4면 범위가 A[2] ~ A[4]인데 이 때 이미 1, 5는 아웃임 2, 3, 6인데

여기서 가장 첫 원소인 2가 최소값으로 출력되면 되는? 부분인것같은데

i = 0 : A[0] ~ A[0]
i = 1 : A[0] ~ A[1]
i = 2 : A[0] ~ A[2]
i = 3 : A[1] ~ A[3]
i = 4 : A[2] ~ A[4]
i = 5 : A[3] ~ A[5]
i = 6 : A[4] ~ A[6]

으로 진행되면서

i = 3에서 출력은 2여야 하는데?

이러려면 push는 push지만 pop도 되어야 한다. 예를 들어서 저 i = 3 : A[1] ~ A[3]은 {5, 2, 3}을 보고 있는데

이게 window가 한 칸씩 이동하는 과정 속에서 5가 앞에 있고 이게 최솟값이냐? 하면 그게 아니니까

2를 넣을 때에 5를 pop 해야 하는 과정이 필요한 것이다

대충... 대충 감이 온다 아오 씨1발

i = 3 : A[1] ~ A[3]에서

범위에 맞지 않는 A[0]은 pop 하고
A[3]이 push되는데 그 이전에 i = 1에서 입력된 5가 i = 2에서 2가 입력될 때에 pop 되어야 한다

그렇게 단계를 좀 구체화 해 보면

i를 통해서 순회할 때에

일단 deque의 size는 L보다 작거나 같고

그 와중에 i를 순회하면서 window가 지나가면? 가장 첫 번쨰 원소가 pop_front() 된다

그리고 새로운 원소가 들어온다? 그러면 가장 뒤의 원소와 비교함
그러니까 현재 인덱스의 원소를 보고
deque의 가장 뒤 원소를 본다
비교했는데 가장 뒤 원소가 더 크다? 그러면 pop_back() 함
pop 하고 나서도 더 남아있을 수 있으니 계~~속 비교하면서 현재 인덱스의 원소보다 큰 원소가 없을 때까지 다 pop 한다
이게 맞을듯

그러고 나면 뭐가 남냐?

현재 윈도우에서

현재 인덱스의 원소보다는 큰 놈이 없게 된다(현재 인덱스의 원소보다 작은 놈이 있을 수는 있음. 더 앞 인덱스의 deque에서)

그리고 그놈은? 언젠가 window 사이즈 L에 의해서 반드시 pop_front 된다

이런 필터링을 하고 난 뒤에 현재 원소를 deque에 push_back 한다

그리고 나서 deque의 front를 보면? 그게 지금 윈도우의 최소값임

이걸 vector에 넣든 cout을 때려버리든 하면 된다

오케이...

존나어렵네

이 인덱스를 deque에 넣는 게 맞나?

아니면 인덱스에 해당하는 수열의 값을 deque에 넣는 게 맞나?

어느 쪽이든 가능하긴 할 것 같은데

인덱스를 넣는 걸로 하자...


*/