#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#include <stack>
#include <cstring>
#include <string>

using namespace std;

int main() 
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    int N;
    cin >> N;

    vector<int> height(N, -1);

    for(int i = 0 ; i < N; i++)
    {
        cin >> height[i];
    }

    long long int answer = 0;

    stack<int> s;

    for(int i = 0; i < N; i++)
    {
        if(s.empty())
        {
            s.push(height[i]);
            continue; // tq
        }
        else
        {
            while(!s.empty() && s.top() <= height[i])
            {
                s.pop();
            }
        }

        answer += s.size();

        s.push(height[i]);
    }

    cout << answer << '\n';

    return 0;
}

/*

빌딩의 개수가 80000까지 주어질 수 있으면
80000!회를 연산할 수 있는가? 했을 때 당연히 X 이고...

스택을 어떻게 사용하느냐?

예시를 보면
N=6, H = {10, 3, 7, 4, 12, 2}
에서, 

1번 건물이 2, 3, 4번은 관측할 수 있어도 6번을 관측할 수 없다?

그리고 3번 건물은 4번만 볼 수 있다?

5번 건물도 6번만 볼 수 있다?

그러면 여기서 스택을 어떻게 사용해야 하지?

이번 문제도 역방향에서의 생각을 좀 해보자

정답을 vector<int> answer(N, 0) 으로 두고

예시의 경우에는 answer[5] = 0;

그리고 H[5] = 2를 스택에 삽입.

이제 H[4] = 12를 관찰

스택의 top = 2와 비교

H[4] = 12 > top = 2 이므로 스택에서 pop

이렇게 answer[4] = 1; 그리고 H[4] = 12를 스택에 push

H[3] = 4를 관찰

스택의 top에 현재 H[4] = 12가 있음

H[3] 이놈 비교를 해 보니까 top이 더 큼

그러면 pop을 하지 않는다. answer[3] = 0; 스택에 H[3] = 4를 push -> 스택에 4, 12 가 있음

H[2] = 7과 스택의 top인 H[3] = 4를 비교

H[2]가 더 크므로 스택에서 pop. 또 top인 12와 비교하면 H[2]가 더 작으므로

pop 하지 않는다. 

answer[2] = 1; 스택에 H[2] = 7을 push. -> 스택에 7, 12가 있음

H[1] = 3을 관찰. 스택의 top인 H[2] = 7과 비교

H[1]이 더 작으므로 pop하지 않는다. 그리고 H[1] = 3을 push -> 스택에 3, 7, 12가 있음

H[0] = 10을 관찰. 그런데

이 경우에는 H[3] = 4가 존재하지 않아서

실제로는 3, 7, 4 와 비교하면서 pop을 하고, answer++를 3번 실행해야 하는데

12를 만날 때까지 2번밖에 실행할 수 없다.

이런 식의 스택 사용이 아닌 건가?

결국 이... 뭐라고 했더라 이 모노톤 스택이라는 것이...

어떻게 여기서 사용될 수 있는 건가

순방향으로 해야 하는 건가 오히려?

일단 H[0] = 10 을 관찰. 스택이 비어있고 이를 넣는다.

H[1] = 3을 관찰. 스택에 10이 있고, 10보다 작으므로 스택에 3을 push.

answer를 벡터라고 생각하지 않고 계속해서 더해나가는 정수라고 생각하면서 answer++;

H[2] = 7을 관찰. 스택에 3이 있고, 3보다 크므로 3을 pop. 그리고 7을 push.

스택에는 {7, 10}이 있고, answer++;(10의 입장)

H[3] = 4를 관찰. 스택의 top이 7이고, 4가 7보다 작으므로 4를 push하지 않음.

그리고 스택에서의 건물이 7, 10이므로 answer++를 두 번 실시. (7, 10의 입장)

H[4] = 12를 관찰. 스택의 top이 7이고, 12가 7보다 크므로 7을 pop.

top이 된 10과 12를 비교해서 12가 더 크므로 10을 pop. 이제 스택은 비어 있음

그 상태에서 12를 스택에 push.

H[5] = 2를 관찰, 스택의 size가 1이고, top이 12이므로 2를 push.

answer++; (12의 입장)

그 다음 인덱스는 없다.

이렇게 하면 answer 1 + 1 + 2 + 1 = 5 가 된다. 정답과 일치함

이 로직을 어떻게 정제할 수 있나?

일단 배열을 인덱스에 따라 순회함

스택이 비어있으면 현재 인덱스의 원소를 push함

원소를 보고 비교함

1. 현재 스택의 사이즈가 0이면 일단 그 원소를 push. (다음 단계들과 관계 없이. 기준 건물이 되니까)
2. 현재 원소의 크기가 top보다 크면, 현재 원소의 크기보다 큰 원소가 스택의 top에서 발견될
때까지 pop 함
3. top보다 작으면, push 예정. 아니... top보다 작든 크든 push되겠지요?
2번에서 작든 크든 현재 원소와 비교해서 pop 하게 되니까.
4. 일단 현재 스택의 size 만큼 answer++를 해준다.
5. 그 뒤에 현재 원소를 스택에 push함

1부터 80000까지의 합은 얼마인가

n(n + 1) / 2를 했을 때

80000 * 80001 / 2 = 3,200,040,000 << int 초과네 세상에


*/